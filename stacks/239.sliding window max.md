brute force:
    - for each window, scan through the window and get the max O(K*N)
    - if use heap: for each window slid, pop out the window front element and keep everything else in (KlogK), then add the new element in. this results even worse time O(N*KlogK)
optimized:
    - monotonic deque.


```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;
    vector<int> ans;
    //deque does not store all values in the curr window, only stores values that are monotonically decreasing from the largest value
    for (int i=0; i<nums.size(); i++) {
        if (!dq.empty() && dq.front() == i-k)  //out of the window 
            dq.pop_front();

        //remove all those elements in the window that are smaller than curr
        while (!dq.empty() && nums[dq.back()] <= nums[i])
            dq.pop_back();

        dq.push_back(i);

        //start building the result starting from the first valid window
        if (i>=k-1) 
            ans.push_back(nums[dq.front()]);
    }
    return ans;
}
```
