Logic
  - Data structure used: 
    - Use an hashset to store each elements in the array. This is used to address duplicate numbers(using duplicated elements will be a problem for the algorithm) as well as to have a O(1) look up time whenever we need to find the lower/upper boundaries from the current sequence.
  - Algorithm:
    - The core step is for each element we find IN the array and the set, we delete it from the set (to prevent other sequence of using the same element again). Then we try to use the current element as A middle point of its sequence and try to look for the element with its left/right boundary value in the hashset. If we can find it, then we remove them from the set and keep incrementing/decrementing their values until neither can be found in the hashset. Each sequence building extends the sequence as long as possible. Hence, once we use an element, the same element cannot be used in another longer sequence, hence we won't use the same element in more than one built sequence. 
    - We will only build sequence IF the current element is still in the hashset (meaning it has not been considered by other sequence yet). If the current element being visited is not found in the hashset, it means we have already accessed and used it as a part of the sequence extension for other elements. 
 - Code below 
 ```cpp
 class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int>record(nums.begin(), nums.end());
        int res = 0;
        for (int n:nums){
            if (record.find(n) == record.end()) continue;
            record.erase(n);
            int prev = n-1, next = n+1;
            while(record.find(prev) != record.end()){
                record.erase(prev);
                prev--;
            }
            while(record.find(next) != record.end()){
                record.erase(next);
                next++;
            }
            res = max(res, next-prev-1);
        }
        return res;
    }
};
```
