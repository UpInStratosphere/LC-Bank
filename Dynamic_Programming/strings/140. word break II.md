- since must be completely broken down, then build the modified strings from the back
    - once a subtring is checked whether it can be completely broken down, its answer will not change even if it is reached there by different combination of prefix words.
- each substring is a node, the different length strings are different nodes in the graph
    - longer susbtring is on the top, shorter substring is on the lower level.
    - the entire question can be thought of finding all different paths from source (complete string) to the target node (empty string - all broken down)

```cpp
vector<string> wordBreak(string s, vector<string>& wordDict) {
    if (s.empty()) return vector<string>{};
    unordered_set<string>dict;
    for (auto word : wordDict){
        dict.insert(word);
    }
    unordered_map<int, vector<string>>memo;
    return build(s, 0, dict, memo);
}

//memo[index] = the formed string for string[index:-1]
//either a vector of string with spaces or an empty vector
vector<string>build(const string &s, int index, const unordered_set<string>&dict, unordered_map<int, vector<string>>&memo){
    if (memo.find(index) != memo.end())
        return memo[index];

    vector<string>res; //cache all valid stringsbuilt from string[index:-1]

    if (index == s.size()){
        string temp = "";
        res.push_back(temp);
    }
    else{
        for (int i = index; i < s.size(); i++){ //for each valid prefix
            string prefix = s.substr(index,i-index+1); 
            if (dict.find(prefix) != dict.end()){ 
                vector<string>temp = build(s, i+1, dict, memo); 
                for (int j = 0; j < temp.size(); j++){ 
                    if (temp[j].empty())
                        res.push_back(prefix);
                    else
                        res.push_back(prefix + " " + temp[j]);
                }
            }
        }
    }
    memo[index] = res;
    return res;
}
```
