- each subproblem(substrings that need to be broken down) is a node, so there are total N different nodes
    - each shorter substring to be checked after a valid word is found at prefix is a neighbor node
    - finding all different paths from source node (complete string) to the target node (empty string)
- DFS for graph traversal 
    - target node is the base case (only one valid target node)
    - each intermediate node will either 
        - return an empty path vector
        - return a vector of paths from the curr node to target node (base case)

```cpp
vector<string> wordBreak(string s, vector<string>& wordDict) {
    if (s.empty()) return vector<string>{};
    unordered_set<string>dict;
    for (auto word : wordDict){
        dict.insert(word);
    }
    unordered_map<int, vector<string>>memo;
    return build(s, 0, dict, memo);
}

//memo[index] = the formed string paths from curr string checked to empty string
//path [curr] = curr + path[neighbor]

vector<string>build(const string &s, int index, const unordered_set<string>&dict, unordered_map<int, vector<string>>&memo){
    //base case: when the curr node is the target node -> empty string 
    if (index == s.size()){
        vector<string>res;
        res.push_back("");
        return res;
    }
    
    //memo case
    if (memo.find(index) != memo.end())
        return memo[index];
  
     //recursive case: when curr string needs to be calculated
    vector<string>res = {}; 
    for (int i = index; i < s.size(); i++){
        string prefix = s.substr(index,i-index+1); 
        if (dict.find(prefix) != dict.end()){ //edges are calculated as we go
            vector<string>temp = build(s, i+1, dict, memo); 
            for (int j = 0; j < temp.size(); j++){ 
                if (temp[j].empty())
                    res.push_back(prefix);
                else
                    res.push_back(prefix + " " + temp[j]);
            }
        }
    }
    memo[index] = res;
    return res;
}
```
