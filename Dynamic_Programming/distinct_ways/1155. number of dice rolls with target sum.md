- brute foce:
    - try out all the possible ways of d^f ways and count those that reached the target number
    - there are total of d levels, and for each level, we have 1 to f of braches to choose at each level 
- optimized: memo[dices remaining][target num remaining] = parameters to indicate the state of each subproblem
    - for each face value, there are d-1 remaining dices to choose from and to reach remaining target number
    - there are many ways to reach current remaining dices and current remaining target number given the order of the choices         create different ways (permutation instead of combination), so cache each DP state.



```cpp
int MOD = 1000000000 + 7;
unordered_map<string,int>memo;

int numRollsToTarget(int d, int f, int target) {
    //base case: 
    //invalid - min possible amount is too big or max possible amount too small to be remaining target
    //valid - exact d dices used and total sum is target
    if (d > target || d*f < target)
        return 0;
    if (d == 0 && target == 0)
        return 1;

    //recursive case
    string key = to_string(d) + "|" + to_string(target);
    if (memo.find(key) != memo.end())
        return memo[key];
    
    int res = 0;
    //for curr dice selection, combine all the ways formed from remaining dices that reach remaining target
    for (int i = 1; i <= f; i++){ 
        if (target >= i){
            res += numRollsToTarget(d-1, f, target-i);
            res %= MOD;
        }
        else
            break;
    }
    memo[key] = res;
    return res;
}
```
