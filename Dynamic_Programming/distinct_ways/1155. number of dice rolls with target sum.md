- brute foce:
    - try out all the possible ways of d^f ways and count those that reached the target number
    - there are total of d levels, and for each level, we have 1 to f of braches to choose at each level 
- optimized:
    - for each face value, there are d-1 remaining dices to choose and to reach target number - face value
    - there are many ways to reach current remaining dices and current remaining target number, so cache the result.
    - because the order of the values matter, this is a permutation problem.


```cpp
int MOD = 1000000000 + 7;
unordered_map<string,int>memo;

int numRollsToTarget(int d, int f, int target) {
    //base case: 
    //invalid - min possible amount is too big or max possible amount too small to be remaining target
    //valid - exact d dices used and total sum is target
    if (d > target || d*f < target)
        return 0;
    if (d == 0 && target == 0)
        return 1;

    //recursive case
    string key = to_string(d) + "|" + to_string(target);
    if (memo.find(key) != memo.end())
        return memo[key];
    
    int res = 0;
    //for curr dice selection, combine all the ways formed from remaining dices that reach remaining target
    for (int i = 1; i <= f; i++){ 
        if (target >= i){
            res += numRollsToTarget(d-1, f, target-i);
            res %= MOD;
        }
        else
            break;
    }
    memo[key] = res;
    return res;
}
```
