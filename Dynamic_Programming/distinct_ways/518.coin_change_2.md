for each amount from 0 to target, total amount = the number of ways an amount can be formed with each coin denomination ALONE starting from .
- base case is no coins used
- fill up the entire value with each coin denomination
- dp[i] = all ways of previous denomination + current denomination
- only values that are larger than the current coin denomination can be affected by the coin
    
dp[i][j] : the number of combinations to make up amount j by using the first i types of coins

State transition:
- not using the current ith coin, only using the first i-1 coins to make up amount j, then we have dp[i-1][j] ways.
- using the ith coin, since we can use unlimited same coin, we need to know how many ways to make up amount j - coins[i-1] by using first i coins(including ith), which is dp[i][j-coins[i-1]]
Initialization: dp[i][0] = 1

```cpp
int change(int amount, vector<int>& coins) {
    if (amount == 0) return 1;
    if (coins.empty()) return 0;
    int n = coins.size();
    vector<int>dp(amount+1, 0);
    dp[0] = 1;
    //adding each type of coins layer by layer
    for (int coin : coins){
        for (int j = coin; j <= amount; ++j){
            dp[j] = dp[j]+ dp[j-coin];
        }
    }
    return dp[amount];
}
```
