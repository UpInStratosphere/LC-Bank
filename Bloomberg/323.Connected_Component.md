DFS
    - Needs to construct the graph in adjacency list before we can use DFS to count connected components
    - Find the number of connected components in the graph that's represented by adjacency list
```cpp
int countComponents(int n, vector<vector<int>>& edges) {
        if (n == 0) return 0; 
        int res = 0;
        unordered_map<int, vector<int>>graph;   
        for (int i = 0; i < n; i++){ //need to account for all nodes, even if it doesn't have an edge (standalone group)
            graph[i] = {};
        }
        for (int i = 0; i < edges.size(); i++){ //use undirected edges to create neighbor list for each node
            graph[edges[i][0]].push_back(edges[i][1]);
            graph[edges[i][1]].push_back(edges[i][0]);
        }
        
        //each node : start a new disjoint group if not already included in a group
        unordered_set<int>visited; 
        for (int i = 0; i < n; i++){ 
            if (visited.find(i) == visited.end()){ 
                DFS(graph, i, visited);
                res+=1;
            }
        }
        return res;
    }
    
    void DFS(unordered_map<int, vector<int>>&graph, int node, unordered_set<int>&visited){
        if (visited.find(node) != visited.end()) //could be added in the group by another group or by the current group
            return;
        
        visited.insert(node);
        
        for(int i = 0; i < graph[node].size(); i++){
            DFS(graph, graph[node][i], visited);
        }
    }
```
Union find
- Just need to initialize the DSU with all the nodes, then can count the connected components as we build in each edge

```cpp
class DSU {
private:
    unordered_map<int,int>parent; // node -> end root 
    unordered_map<int,int>rank;   // node -> rank
public:
    DSU(int nodes){
        for (int i = 0; i < nodes; i++){
            parent[i] = i;
            rank[i] = 0;
        }
    };
    
    //also need to write a destructor
    
    //finding the end root of the node
    int find(int x){
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    
    bool connected(int x, int y){ //in the same component
        return find(x) == find(y);
    }
    
    void merge(int x, int y){
        int rootx = find(x);
        int rooty = find(y);
        if (rootx == rooty) return; //already in the same component
        else if (rank[rootx] > rank[rooty])
            parent[rooty] = rootx;
        else if (rank[rootx] < rank[rooty])
            parent[rootx] = rooty;
        else{
            parent[rooty] = rootx;
            rank[rootx]++;
        }
    }
};

class Solution {
public:
int countComponents(int n, vector<vector<int>>& edges) {
    int total = n; //each node is an individual component before unionfind
    DSU *dsu = new DSU(n);
    for (auto edge : edges){
        int x = edge[0], y = edge[1];
        if (dsu->connected(x,y) == false){ //if not in the same component, merge and decrese the initial total by 1
            dsu->merge(x,y);
            total--;
        }     
    }
    return total;
}
```
