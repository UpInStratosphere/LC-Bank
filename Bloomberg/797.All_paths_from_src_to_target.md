- Here, need to use backtracking instead of DFS to visit all the paths BECAUSE different parent nodes can lead to the same suffix paths. So all path combinations need to be visited.


```cpp
void helper(vector<vector<int>>&graph, int curr, int target, vector<int>&path, vector<vector<int>>&res, unordered_set<int>&visited){
    if (visited.find(curr) != visited.end()) return;

    path.push_back(curr);
    visited.insert(curr);

    if (curr == target)
        res.push_back(path);
    else{ //each neighbor is visited sequentially. 
        for (int nei : graph[curr]){
            helper(graph, nei, target, path, res, visited);
        }
    }
    //when here, all paths are already all finished, we are just resetting the visited status
    visited.erase(curr);
    path.pop_back();
}
```

- if asked for total number of paths from source to target, use DFS + memo
    - memo[node] : total paths from the node to target node
    - initialze all memo[node] = -1 to indicate that this node has not be processed

```cpp
int DFS(graph, int curr, int dst, unordered_map<int, int>memo){
    if (memo[curr] != -1) return memo[curr];
    if (curr==dst) return 1; 
    
    int res = 0;
    for (int neighbor : graph[curr]){
        int temp = DFS(graph, neighbor, dst, memo);
        res += temp;
    }
    memo[curr] = res;
    return res;
}
```
        
