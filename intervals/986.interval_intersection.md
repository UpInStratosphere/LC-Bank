- sorted, disjoint interval groups
- intersection of these lists is similar to 2-way mergesort
    - if an intersection exists, then it must be with the interval from the other group (need both lists to compare)
- intersection is formed between the bigger start and smaller end of the interval
    - smaller start and larger end are the boundaries of the newly formed overlapping interval group
    - next interval checked is the one after the smaller end (the one after bigger end will not overlap with the curr group)
    
```cpp
vector<vector<int>> intervalIntersection(vector<vector<int>>& A, vector<vector<int>>& B) {
    if (A.empty() || B.empty()) return vector<vector<int>>{};
    vector<vector<int>>res;
    int n = A.size(), m = B.size();
    int i = 0, j = 0;
    
    while (i < n && j < m){
        
        int start = max(A[i][0], B[j][0]);
        int end = min(A[i][1], B[j][1]);
        
        if (start <= end)
            res.push_back(vector<int>{start, end}); 
        
        if (A[i][1] > B[j][1]) 
            j++;
        else
            i++;
    }
    return res;
}
```

follow up: merge intervals of 2 sorted lists

```cpp
vector<vector<int>>intervalMerging(vector<vector<int>>& A, vector<vector<int>>& B){
    if (A.empty() || B.empty()) return vector<vector<int>>{};
    vector<vector<int>>res;
    int n = A.size(), m = B.size();
    int i = 0, j = 0;
    
    //get the initial group started
    if (A[i][0] < B[j][0]){
        res.push_back(A[i);
        i++;
    else{
        res.push_back(B[j]);
        j++;
    }
    while (i < n && j < m){ 
        //if there is any overlapping of the curr interval group and one of the intervals checked
        if (A[i][0] <= res.back()[1]){
            res.back()[1] = max(res.back()[1], A[i][1]);
            i++;
        }
        else if (B[j][0] <= res.back()[1]){
            res.back()[1] = max(res.back()[1], B[j][1]);
            j++;
        }
        //if there is no overlapping, then push in the smaller start interval as the next group
        else if (A[i][0] < B[j][0]){
            res.push_back(A[i]);
            i++;
        }
        else{
            res.push_back(B[j]);
            j++;
        }
    }
    
    //merge the remaining intervals from the list with the merged intervals
    while (i < n){
        if (A[i][0] <= merged.back()[1]){
            int min_start = min(A[i][0], merged.back()[0]);
            int max_end = max(A[i][1], merged.back()[1]);
            merged.back() = {min_start, max_end};
        }
        else
            merged.push_back(A[i]);
        i++;
    }
    while (j < B.size()){
        if (B[j][0] <= merged.back()[1]){
            int min_start = min(B[j][0], merged.back()[0]);
            int max_end = max(B[j][1], merged.back()[1]);
            merged.back() = {min_start, max_end};
        }
        else
            merged.push_back(B[j]);
        j++;
    }
    return res;
}
    
```
            
