- the edges indicates that two nodes have symmetric and transitive properties
- divide the graph into disjoint components
- when there are more than 1 max components, we need to cure the node with the smallest value
    - smallest index means the smallest value node
    
```cpp
int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    if (graph.empty()) return 0;
    unordered_set<int>infected;
    for (int sick : initial)
        infected.insert(sick);
    unordered_set<int>visited; 
    int mx = 0;
    int res = INT_MAX; //default value for the cured node. No change if no component has only 1 sick node
    for (int i = 0; i < graph.size(); i++){
        if (visited.find(i) != visited.end()) continue;
        int total = 0;
        unordered_set<int>sick;
        helper(graph, i, total, visited, sick, infected); //find all connected nodes to the curr node
        if (sick.size() == 1){
            if (total > mx){
                mx = total;
                res = *sick.begin();
            }
            else if (total == mx){
                int temp = *sick.begin();
                res = min(res, temp);
            }
        }
    }
    
    //none of the group had only 1 initial sick node, so cure the smallest node
    if (res == INT_MAX) {
        for (int node : initial)
            res = min(node, res);
    }
    return res;
}

void helper(const vector<vector<int>>&graph, int curr, int &total, unordered_set<int>&visited, unordered_set<int>&sick, const unordered_set<int>&infected){
   if (visited.find(curr) != visited.end()) return;

   total += 1;
   visited.insert(curr);
   if (infected.find(curr) != infected.end())
       sick.insert(curr);

   for (int i = 0; i < graph[curr].size(); i++){
       if (graph[curr][i] == 1){ //instead of for each connected neighbor
           helper(graph, i, total, visited, sick, infected);
       }
   }   
}   
```
