- Use backtracking to visit all the paths BECAUSE different parent nodes can lead to the same suffix paths that lead to target node and result different paths. Worst case all paths are valid paths. 
- DFS + memo can be used as well, even though it does not change the asymptotic time comeplexity

-Backtracking: O(2^N) where total node visit times will be 2^N times.
```cpp
void helper(vector<vector<int>>&graph, int curr, int target, vector<int>&path, vector<vector<int>>&res, unordered_set<int>&visited){
    if (visited.find(curr) != visited.end()) return;

    path.push_back(curr);
    visited.insert(curr);

    if (curr == target)
        res.push_back(path);
    else{ 
        for (int nei : graph[curr]){
            helper(graph, nei, target, path, res, visited);
        }
    }
    //when here, all paths are already all finished, we are just resetting the visited status
    visited.erase(curr);
    path.pop_back();
}
```
- DFS + memo: O(2^N) * N due to possible 2^N paths construction, but each node only will be traversed once
```cpp
vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        if (graph.empty()) return vector<vector<int>>{};
        unordered_map<int, vector<vector<int>>>memo; //each node stores all the paths it has to the target node
        return helper(graph, 0, memo);
    }
    
vector<vector<int>> helper(const vector<vector<int>>&graph, int curr, unordered_map<int,vector<vector<int>>>&memo){
    
    if (memo.find(curr) != memo.end())
        return memo[curr];
    
    vector<vector<int>>res;
    if (curr == graph.size()-1){
        res.push_back({curr});
    }
    else{
        for (int i = 0; i < graph[curr].size(); i++){
            vector<vector<int>>paths = helper(graph, graph[curr][i], memo);
            for (auto path : paths){
                path.insert(path.begin(), curr);
                res.push_back(path);
            }
        }
    }
    memo[curr] = res;
    return res;
}
```
- find total number of paths from source to target, use DFS + memo
    - memo hashmap can also serve as the visited hashmap 
    - memo[node] : total paths from the node to target node
    - no need to initialize to a negative value if we use a hashmap
        - if not processed, not found in hashmap
        - if processed but no paths, just return 0
        - if processed and have paths, just return path number
    - curr node's total path number is the number of paths added for all neighbor nodes

```cpp
int DFS(graph, int curr, int dst, unordered_map<int, int>memo){
    if (memo.find(curr) != memo.end()) return memo[curr];
    
    int res = 0;
    if (curr==dst) 
        res+=1; 
    else{
        for (int neighbor : graph[curr]){
            int temp = DFS(graph, neighbor, dst, memo);
            res += temp;
        }
    }
    memo[curr] = res;
    return res;
}
```
        
