- only need to figure out the total number of slots that are needed to execute all tasks.
- each segment (n+1 size) of unique task starts with the max-freq task and choose each next task based on decreasing freq
        - if unique tasks run out, check to see if we have any more remaining instances of tasks to execute
          - if yes, then fill the remaining extra slots in current segment with idle slots to satisfy the condition
          - if no, then this is the last segment and the condition is satisfied.

- given each task is a character, there can only be 26 unique characters, so even with priority queue, the total time is Nlog26.

```cpp
int leastInterval(vector<char>& tasks, int n) {
        int res = 0, total = tasks.size(); 
        unordered_map<char, int> m;
        priority_queue<int>max_heap;
        for (char c : tasks) ++m[c]; 
        for (auto a : m) pq.push(a.second); //uses each frequency to track each unique task
        
        while (!max_heap.empty()) {
            int cnt = 0; //number of actual tasks included in the curr segment (not including idle slots)
            int full = n+1; //the full size of each segment of unique tasks (with idle spots)
            vector<int>remain; 
            //if pq runs out while filling out current segment, then the remaining slots in the curr segment must be idle 
            for (int i = 0; i < full; ++i) { 
                if (!max_heap.empty()) { 
                    int curr = max_heap.top();
                    max_heap.pop();
                    curr--;
                    if (curr > 0) remain.push_back(curr);
                    ++cnt;
                }
                else 
                    break;
            }
            
            if (remain.empty()){
                res += cnt;
                return res;
            }
            res += full;
            for (int d : remain) { 
                max_heap.push(d);
            } 
        }
        return res;
    }
```
