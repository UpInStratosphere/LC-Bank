- only need to figure out the total number of slots that are needed to make n-sized chunks.
- each chunk starts with the current max freq task, and will have n+1 of tasks in the chunk (since there need to be n+1 tasks in each chunk)
- for each chunk, fill it will the actual tasks, starting from the most freq task. Then fill the remaining extra slots with idle slots.

```cpp
int leastInterval(vector<char>& tasks, int n) {
        int res = 0, total = tasks.size(); 
        unordered_map<char, int> m;
        priority_queue<int>max_heap;
        for (char c : tasks) ++m[c]; 
        for (auto a : m) pq.push(a.second); //uses each frequency to track each unique task
        
        while (!max_heap.empty()) {
            int cnt = 0; //number of actual tasks included in the curr chunk (not including idle slots)
            int full = n+1; //the full size of each chunk of unique tasks (with idle spots)
            vector<int>remain; 
            //if pq runs out while filling out current chunk, then the remaining slots in the chunk must be idle 
            for (int i = 0; i < chunk; ++i) { 
                if (!max_heap.empty()) { 
                    int curr = max_heap.top();
                    max_heap.pop();
                    curr--;
                    if (curr > 0) remain.push_back(curr);
                    ++cnt;
                }
                else 
                    break;
            }
            
            if (remain.empty()){
                res ++ cnt;
                return res;
            }
            res += full;
            for (int d : remain) { 
                max_heap.push(d);
            } 
        }
        return res;
    }
```
