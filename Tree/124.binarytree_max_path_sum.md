- the path doesn't have to go through root, but the solution path must have one of the node as the root node
    - for each node from the bottom, find the max path for each node used as a root.
- max of local max must be the global max.
    - processing each node from the bottom up by checking the left subtree, then right subtree. Each is a local subproblem

```cpp
int maxPathSum(TreeNode* root) {
        if (!root) return 0;
        int res = INT_MIN;
        helper(root, res);
        return res;
}

int helper(TreeNode *node, int &res){
    if (!node) return 0;
    
    int left_sum = helper(node->left, res);
    int right_sum = helper(node->right, res);
    
    inr curr_sum = node->val + max(0, left_sum) + max(0, right_sum);
    res = max(res, curr_sum);
    
    return max(max(left_sum, right_sum),0) + node->val; //can only take one path, and only if its sum is > 0
}
```
    
