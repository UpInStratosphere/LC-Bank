# Majority Element
- logic (the majority element will appear greater than n/2 times)
  - Hashmap: use a hashmap (key = element, value = frequency), then return the key while building the hashmap
  - partition: because the majority will appear MORE than n/2 times, that means the n/2 element will be the majority element.So use the quick partition method. Average time = O(n), space = O(1), but data is corrupted
  - Boyer Moore Technique: guaranteed O(n) time and O(1) space
    - We cancel out each occurrence of an element A with all the other elements that are different from A then A will exist till end if it is a majority element. Below code loops through each element and maintains a count of the element that has the potential of being the majority element. If next element is same then increments the count, otherwise decrements the count. If the count reaches 0 then current is eliminated from majority and we update the potential index to the next element and sets count to 1. By definition, a majority element will occur more than half of the time if we loop from the beginning to the end. 
    ```cpp
    int current = 0; //starts the potential majority element with the first number
    int count = 1; //the count for the first element is 1 
    for (next = 1; i < num.size(); next++) { //count refers to the frequency of current potential majority element 
        num[current] == num[next] ? count++ : count--; 
        if (count == 0) { //if the next !=current, then current index cannot be the majority element. 
            current = next;
            count = 1;
        }
    }
        
    return num[current]; //we just need to return a majority value
    ```
    
    
