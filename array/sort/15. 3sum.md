Need **unique** trilets (meaning the value combinations in the triplet must be unique) that have a specific sum
    - uniqueness comes from the value of the elements, not the index of the elements
- duplicate values should not be used in the same index in the triplet
- sorting achieve the optimization AND allows to skip duplicate values for the triplet indices
    - optimization happens because if curr second and curr third doesn't work, then all the prior seconds don't work with curr third because their sums would be too small, and all prior third don't with curr second because their sums would be too big. This property saves time to repeated check elements from the start.


```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    int n = nums.size();
    sort(nums.begin(), nums.end());
    vector<vector<int>>res;
    for (int first = 0; first <= n-3; first++){
        if (first > 0 && nums[first] == nums[first-1]) continue;
        int second = first+1, third = n-1;
        while(second < third){
            int sum = nums[first] + nums[second] + nums[third];
            if (sum == 0){
                res.push_back({nums[first], nums[second], nums[third]});
                second++;
                third--;
                while(second < third && nums[second] == nums[second-1])
                    second++;
                while(second < third && nums[third] == nums[third+1])
                    third--;
            }
            else if (sum < 0)
                second++;
            else
                third--;
        }
    }
    return res;
}
```
