- greedy approach:
    - if the curr minsized substring works, then any longer substring that contains this substring will either
        - add more unique chars (may invalidate the longer susbtring) OR 
        - add a same char already included (both curr and longer substrings work)
    - So **any valid longer substring that contains a shorter valid substring will never appear more than the valid shorter substring** 
    - check each unique minsized valid substring and find the max freq 
- but this only works for getting the max freq, cannot be used to find all most freq substrings (because this method does not track the longer substrings that also satisfy the condition)

```cpp
int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
    int start=0, result=0;
    unordered_map<int,int>window;           	
    unordered_map<string,int>freq;    
    for(int i=0; i<s.size(); i++){
        window[s[i]]++;
        //shrink the window whenever the current window exceeds min length (tracking each minsized sliding window)
        if(i-start+1>minSize){
            window[s[start]]--;
            if(window[s[start]] == 0)			
                window.erase(s[start]);
            start++;
        }
        if(i-start+1==minSize && window.size() <= maxLetters)	
           string curr = s.substr(start,i-start+1);
           freq[curr]++; 
           res = max(res, freq[curr]);
    }
    return result;
}
```
